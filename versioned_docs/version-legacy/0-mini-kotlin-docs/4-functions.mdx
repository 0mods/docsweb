---
sidebar_position: 4
title: Функции в Kotlin
id: kotlin-functions
description: 'Подробное руководство по функциям в Kotlin: аргументы, lambda, высшие функции и прочее'
author: 'dan_bat'
---

<div align="center">

# Функции в `Kotlin`

---

<br />

:::tip Что такое функции?
Функции позволяют группировать повторяющийся код в блоки для повышения читаемости и повторного использования. Они могут принимать аргументы, возвращать значения и быть объявлены в различных формах.
:::

<br />

## Создание функций и принципы именования

<div align="left">

### Создание функции

В Kotlin функции создаются с помощью ключевого слова `fun` с последующим именем, списком параметров и телом функции.

```kts title="Пример создания функции"
fun sayHello() {
    println("Hello, Kotlin!")
}
```

### Принципы именования функций

- **CamelCase:** Имена функций должны начинаться с маленькой буквы, например, `calculateSum()` или `getUserData()`.
- **Глагол + Существительное:** Имена функций обычно содержат глагол, отражающий действие, например, `printMessage()` или `fetchData()`.
- **Информативность:** Имя функции должно ясно описывать выполняемое действие.
- **Краткость:** Старайтесь избегать излишне длинных имен, сохраняя при этом ясность.

</div>

<br />
---
<br />

## Аргументы в функции

<div align="left">

Аргументы в функцию передаются по порядку либо по имени передаваемого аргумента, а тип каждого аргумента указывается после его названия через двоеточие.

```kts title="Аргументы в функции"
fun greet(name: String, age: Int) {
    println("Привет, $name! Тебе $age лет.")
}

greet("Анна", 25) // или greet(age = 25, name = "Анна")
```

</div>

<br />
---
<br />

## Переменное количество параметров

<div align="left">

Использование ключевого слова `vararg` позволяет передавать в функцию любое количество аргументов.

```kts title="Переменное количество параметров"
fun sum(vararg numbers: Int): Int {
    return numbers.sum()
}

println("Сумма: ${sum(1, 2, 3, 4)}") // Сумма: 10
```

</div>

<br />
 ---
<br />

## Тип Unit

<div align="left">

Функции, не возвращающие значения после выполнения, имеют тип `Unit` (аналог `void` в других языках). При этом тип можно опустить, не писав его явно.

```kts title="Тип Unit"
fun printMessage(message: String): Unit {
    println(message)
}

fun printAnotherMessage(message: String) {
    println(message)
}

printMessage("Привет, мир!")
```

</div>
    
<br />
---
<br />

## Однострочные функции

<div align="left">

Однострочные функции позволяют записывать тело функции в одну строку без использования фигурных скобок, часто используется для простой логики.

```kts title="Однострочная функция"
fun square(x: Int) = x * x

println("Квадрат 5: ${square(5)}") // Квадрат 5: 25
 ```

</div>

<br />
---
<br />

## Локальные функции

<div align="left">

Локальные функции объявляются внутри другой функции и доступны только в её области видимости.

```kts title="Локальные функции"
fun outerFunction() {
    fun innerFunction(x: Int): Int = x + 1 // можно вызвать только в outerFunction
    println("innerFunction(5): ${innerFunction(5)}")
}
    
outerFunction() // Выведет: innerFunction(5): 6
```

</div>

<br />
---
<br />

## Функции-члены

<div align="left">

Функции-члены (методы) объявляются внутри классов и имеют доступ к свойствам экземпляра, подробней в главе об ООП.

```kts title="Функции-члены"
class Calculator {
    fun add(a: Int, b: Int): Int = a + b
}

val calc = Calculator()
println("Сумма: ${calc.add(3, 4)}") // Сумма: 7
```

</div>

<br />
---
<br />

## Функции обобщения

<div align="left">

Обобщенные функции позволяют работать с данными различных типов, используя параметр типа `<T>`.

```kts title="Функции обобщения"
fun <T> printList(list: List<T>) {
    list.forEach { println(it) } // T - это тип элемента списка, в этом примере это String
}

printList(listOf("Apple", "Banana", "Cherry")) // Apple, Banana, Cherry
```

</div>

<br />
---
<br />

## Лямбда функции

<div align="left">

Лямбда функции — это выражения, которые можно сохранять в переменные и передавать как аргументы другим функциям.

```kts title="Лямбда функции"
val sum = { a: Int, b: Int -> a + b }
println("Сумма: ${sum(3, 4)}") // Сумма: 7
```

</div>

<br />
---
<br />

## Функции высших порядков

<div align="left">

Функции высших порядков принимают другие функции в качестве параметров или возвращают их.

```kts title="Функции высших порядков"
fun operate(a: Int, b: Int, op: (Int, Int) -> Int): Int {
    return op(a, b)
}

val result = operate(10, 5) { x, y -> x - y }
println("Результат операции: $result") // Результат операции: 5
```

</div>

<br />
---
<br />

## Анонимные функции

<div align="left">

Анонимные функции похожи на лямбда функции, но позволяют использовать имена параметров и возвращаемое значение без лямбда-выражения.

```kts title="Анонимные функции"
val multiply = fun(a: Int, b: Int): Int {
    return a * b
}

println("Произведение: ${multiply(4, 5)}") // Произведение: 20
```

</div>

<br />
---
<br />

## Дополнительные возможности

<div align="left">

### Функции расширения

Функции расширения позволяют добавлять новые функции к существующим классам без изменения их исходного кода подробней в главе об ООП.

```kts title="Функции расширения"
fun String.addExclamation() = this + "!"
println("Hello".addExclamation()) // Hello!
```

### Рекурсивные функции

Рекурсивные функции вызывают сами себя для решения задач, разбивая проблему на более мелкие подзадачи.

```kts title="Рекурсивные функции"
fun factorial(n: Int): Int = if (n <= 1) 1 else n * factorial(n - 1)
println("Факториал 5: ${factorial(5)}") // Факториал 5: 120
```

</div>

<br />

:::warning Замечание
При использовании функций высших порядков и лямбда функций старайтесь сохранять читаемость кода и избегайте чрезмерной вложенности.
:::

</div>